{"name":"Chroma","tagline":"Ruby gem for color manipulation and palette generation","body":"# Chroma\r\n\r\n[![Gem Version](https://badge.fury.io/rb/chroma.svg)](http://badge.fury.io/rb/chroma)\r\n[![Build Status](https://travis-ci.org/jfairbank/chroma.svg?branch=master)](https://travis-ci.org/jfairbank/chroma)\r\n\r\nChroma is a color manipulation and palette generation library. It is heavily\r\ninspired by and a very close Ruby port of the\r\n[tinycolor.js](https://bgrins.github.io/TinyColor/)\r\nlibrary. Many thanks to [Brian Grinstead](http://www.briangrinstead.com/blog/)\r\nfor his hard work on that library.\r\n\r\nPlease don't hesitate to examine the code and make issues, feature requests,\r\nor pull requests. Please refer to the [Contributing](#contributing) section\r\nbelow.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'chroma'\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install chroma\r\n\r\n## Creating Colors\r\n\r\nColors are created via the `Chroma.paint` method. It expects any one of\r\nmany possible color formats as a string, including names, hexadecimal, rgb,\r\nhsl, and hsv. As a convenience, a `String#paint` is also available for more\r\nsuccinct color creation.\r\n\r\n```ruby\r\n# With Chroma.paint\r\nChroma.paint 'red'                       # named colors\r\nChroma.paint '#00ff00'                   # 6 character hexadecimal\r\nChroma.paint '#00f'                      # 3 character hexadecimal\r\nChroma.paint 'rgb(255, 255, 0)'          # rgb\r\nChroma.paint 'rgba(255, 255, 0, 0.5)'    # rgba\r\nChroma.paint 'hsl(60, 100%, 50%)'        # hsl with percentages\r\nChroma.paint 'hsl(60, 1, 0.5)'           # hsl with decimals\r\nChroma.paint 'hsla(60, 100%, 50%, 0.5)'  # hsla\r\nChroma.paint 'hsv(60, 100%, 50%)'        # hsv with percentages\r\nChroma.paint 'hsv(60, 1, 0.5)'           # hsv with decimals\r\nChroma.paint 'hsva(60, 100%, 50%, 0.75)' # hsva\r\n\r\n# With String#paint\r\n'red'.paint\r\n'#00ff00'.paint\r\n'#00f'.paint\r\n'rgb(255, 255, 0)'.paint\r\n'rgba(255, 255, 0, 0.5)'.paint\r\n'hsl(60, 100%, 50%)'.paint\r\n'hsla(60, 100%, 50%, 0.5)'.paint\r\n'hsv(60, 100%, 50%)'.paint\r\n'hsva(60, 100%, 50%. 0.5)'.paint\r\n```\r\n\r\n## Motivation\r\n\r\nChroma's major strength is manipulating colors and generating color palettes,\r\nwhich allows you to easily generate dynamic colors, dynamic themes for a web\r\napplication, and more.\r\n\r\n## Color Manipulation\r\n\r\n#### Lighten\r\n\r\nLighten the color by a given amount. Defaults to 10.\r\n\r\n```ruby\r\n'red'.paint.lighten     #=> #ff3333\r\n'red'.paint.lighten(20) #=> #ff6666\r\n```\r\n\r\n#### Brighten\r\n\r\nBrighten the color by a given amount. Defaults to 10.\r\n\r\n```ruby\r\n'red'.paint.brighten     #=> #ff1a1a\r\n'red'.paint.brighten(20) #=> #ff3333\r\n```\r\n\r\n#### Darken\r\n\r\nDarken the color by a given amount. Defaults to 10.\r\n\r\n```ruby\r\n'red'.paint.darken     #=> #cc0000\r\n'red'.paint.darken(20) #=> #990000\r\n```\r\n\r\n#### Desaturate\r\n\r\nDesaturate the color by a given amount. Defaults to 10.\r\n\r\n```ruby\r\n'red'.paint.desaturate     #=> #f20d0d\r\n'red'.paint.desaturate(20) #=> #e61919\r\n```\r\n\r\n#### Saturate\r\n\r\nSaturate the color by a given amount. Defaults to 10.\r\n\r\n```ruby\r\n'#123'.paint.saturate     #=> #0e2236\r\n'#123'.paint.saturate(20) #=> #0a223a\r\n```\r\n\r\n#### Grayscale\r\n\r\nConvert the color to grayscale.\r\n\r\n```ruby\r\n'green'.paint.grayscale #=> #404040\r\n\r\n# greyscale is an alias\r\n'red'.paint.greyscale   #=> #808080\r\n```\r\n\r\n#### Spin\r\n\r\nSpin a given amount in degrees around the hue wheel.\r\n\r\n```ruby\r\n'red'.paint.spin(30) #=> #ff8000\r\n'red'.paint.spin(60) #=> yellow\r\n'red'.paint.spin(90) #=> #80ff00\r\n```\r\n\r\n## Generating Palettes\r\n\r\nChroma's most powerful feature is palette generation. You can use the default\r\npalettes available or even create your own custom palettes.\r\n\r\nPalette methods are available via `Color#palette` and by default output an\r\narray of colors. If you want the underlying color strings, you can pass in\r\nthe desired format via the `:as` option.\r\n\r\n#### Available Formats\r\n\r\n* name\r\n* rgb\r\n* hex\r\n* hex6 (alias for hex)\r\n* hex3\r\n* hex8 (includes the alpha value in the highest order byte)\r\n* hsl\r\n* hsv\r\n\r\n#### Complement\r\n\r\nGenerate a complement palette.\r\n\r\n```ruby\r\n'red'.paint.palette.complement            #=> [red, cyan]\r\n'red'.paint.palette.complement(as: :name) #=> ['red', 'cyan']\r\n'red'.paint.palette.complement(as: :hex)  #=> ['#ff0000', '#00ffff']\r\n```\r\n\r\n#### Triad\r\n\r\nGenerate a triad palette.\r\n\r\n```ruby\r\n'red'.paint.palette.triad            #=> [red, lime, blue]\r\n'red'.paint.palette.triad(as: :name) #=> ['red', 'lime', 'blue']\r\n'red'.paint.palette.triad(as: :hex)  #=> ['#ff0000', '#00ff00', '#0000ff']\r\n```\r\n\r\n#### Tetrad\r\n\r\nGenerate a tetrad palette.\r\n\r\n```ruby\r\n'red'.paint.palette.tetrad\r\n#=> [red, #80ff00, cyan, #7f00ff]\r\n\r\n'red'.paint.palette.tetrad(as: :name)\r\n#=> ['red', '#80ff00', 'cyan', '#7f00ff']\r\n\r\n'red'.paint.palette.tetrad(as: :hex)\r\n#=> ['#ff0000', '#80ff00', '#00ffff', '#7f00ff']\r\n```\r\n\r\n#### Split Complement\r\n\r\nGenerate a split complement palette.\r\n\r\n```ruby\r\n'red'.paint.palette.split_complement\r\n#=> [red, #ccff00, #0066ff]\r\n\r\n'red'.paint.palette.split_complement(as: :name)\r\n#=> ['red', '#ccff00', '#0066ff']\r\n\r\n'red'.paint.palette.split_complement(as: :hex)\r\n#=> ['#ff0000', '#ccff00', '#0066ff']\r\n```\r\n\r\n#### Analogous\r\n\r\nGenerate an analogous palette. Pass in a `:size` option to specify the size\r\nof the palette (defaults to 6). Pass in a `:slice_by` option to specify the\r\nangle size to slice into the hue wheel (defaults to 30 degrees).\r\n\r\n```ruby\r\n'red'.paint.palette.analogous\r\n#=> [red, #ff0066, #ff0033, red, #ff3300, #ff6600]\r\n\r\n'red'.paint.palette.analogous(as: :hex)\r\n#=> ['#f00', '#f06', '#f03', '#f00', '#f30', '#f60']\r\n\r\n'red'.paint.palette.analogous(size: 3)\r\n#=> [red, #ff001a, #ff1a00]\r\n\r\n'red'.paint.palette.analogous(size: 3, slice_by: 60)\r\n#=> [red, #ff000d, #ff0d00]\r\n```\r\n\r\n#### Monochromatic\r\n\r\nGenerate a monochromatic palette. Pass in a `:size` option to specify the size\r\nof the palette (defaults to 6).\r\n\r\n```ruby\r\n'red'.paint.palette.monochromatic\r\n#=> [red, #2a0000, #550000, maroon, #aa0000, #d40000]\r\n\r\n'red'.paint.palette.monochromatic(as: :hex)\r\n#=> ['#ff0000', '#2a0000', '#550000', '#800000', '#aa0000', '#d40000']\r\n\r\n'red'.paint.palette.monochromatic(size: 3)\r\n#=> [red, #550000, #aa0000]\r\n```\r\n\r\n## Defining Custom Palettes\r\n\r\nChroma allows you to define your own custom palettes if the default ones aren't\r\nall you're looking for. You can define a custom palette by calling\r\n`Chroma.define_palette`, passing in a palette name and definition block. The\r\ndefinition block uses the color manipulation methods (i.e. `lighten`, `spin`,\r\netc.) as its DSL. Every DSL call defines a new color that will be included\r\nin the palette. Your seed color (i.e. the color from which you call the\r\npalette method) will be included as the first color in your palette too.\r\n\r\n```ruby\r\nred = 'red'.paint\r\n\r\nred.palette.respond_to? :my_palette #=> false\r\n\r\n# Define a palette with 5 colors including the seed color\r\nChroma.define_palette :my_palette do\r\n  spin 60\r\n  spin 180\r\n  spin(60).brighten(20) # chain calls as well\r\n  greyscale\r\nend\r\n\r\nred.palette.respond_to? :my_palette #=> true\r\n\r\nred.palette.my_palette #=> [#ff0000 #ffff00 #00ffff #ffff33 #808080]\r\n```\r\n\r\n## Serializing Colors\r\n\r\nColors offer several methods to output to different string color [formats](#available-formats).\r\n\r\n| Method    | Description                                                                                                      |\r\n| --------- | ---------------------------------------------------------------------------------------------------------------- |\r\n| `to_hsv`  | output to hsv string, outputs hsva if alpha < 1                                                                  |\r\n| `to_hsl`  | output to hsl string, outputs hsla if alpha < 1                                                                  |\r\n| `to_hex`  | output to hex string, optional argument allows 3-character hex output if possible                                |\r\n| `to_hex8` | output to 8-character hex string with alpha value in the highest order byte                                      |\r\n| `to_rgb`  | output to rgb string, outputs rgba if alpha < 1                                                                  |\r\n| `to_name` | output to color name string if available, otherwise `'<unknown>'` or `to_hex` output based on optional arg value |\r\n| `to_s`    | output to the appropriate string format based on how the color was created, optional arg forces the format       |\r\n\r\n```ruby\r\n# to_hsv\r\n'red'.paint.to_hsv                  #=> 'hsv(0, 100%, 100%)'\r\n'rgba(255, 0, 0, 0.5)'.paint.to_hsv #=> 'hsva(0, 100%, 100%, 0.5)'\r\n\r\n# to_hsl\r\n'red'.paint.to_hsl                  #=> 'hsl(0, 100%, 50%)'\r\n'rgba(255, 0, 0, 0.5)'.paint.to_hsl #=> 'hsla(0, 100%, 50%, 0.5)'\r\n\r\n# to_hex\r\n'red'.paint.to_hex                  #=> '#ff0000'\r\n'red'.paint.to_hex(true)            #=> '#f00'\r\n'rgba(255, 0, 0, 0.5)'.paint.to_hex #=> '#ff0000'\r\n'red'.paint.to_hex                  #=> '#ffff0000'\r\n'rgba(255, 0, 0, 0.5)'.paint.to_hex #=> '#80ff0000'\r\n\r\n# to_rgb\r\n'red'.paint.to_rgb                  #=> 'rgb(255, 0, 0)'\r\n'rgba(255, 0, 0, 0.5)'.paint.to_rgb #=> 'rgb(255, 0, 0, 0.5)'\r\n\r\n# to_name\r\n'red'.paint.to_name                  #=> 'red'\r\n'#00f'.paint.to_name                 #=> 'blue'\r\n'rgba(255, 0, 0, 0.5)'.paint.to_name #=> '<unknown>'\r\n'#123'.paint.to_name(true)           #=> '#112233'\r\n\r\n# to_s\r\n'red'.paint.to_s             #=> 'red'\r\n'rgb(255, 0, 0)'.paint.to_s  #=> 'rgb(255, 0, 0)'\r\n'#f00'.paint.to_s            #=> '#f00'\r\n'#80ff0000'.paint.to_s(:rgb) #=> 'rgba(255, 0, 0, 0.5)'\r\n```\r\n\r\n## Other Methods\r\n\r\nColors also have a few other helper methods:\r\n\r\n| Method       | Description                                            |\r\n| ------------ | ------------------------------------------------------ |\r\n| `dark?`      | is the color dark?                                     |\r\n| `light?`     | is the color light?                                    |\r\n| `alpha`      | retrieve the alpha value                               |\r\n| `brightness` | calculate the brightness as a number between 0 and 255 |\r\n| `complement` | return the complementary color                         |\r\n\r\n```ruby\r\n# dark?\r\n'red'.paint.dark?    #=> true\r\n'yellow'.paint.dark? #=> false\r\n\r\n# light?\r\n'red'.paint.light?    #=> false\r\n'yellow'.paint.light? #=> true\r\n\r\n# alpha\r\n'red'.paint.alpha                #=> 1.0\r\n'rgba(0, 0, 0, 0.5)'.paint.alpha #=> 0.5\r\n\r\n# brightness\r\n'red'.paint.brightness    #=> 76.245\r\n'yellow'.paint.brightness #=> 225.93\r\n'white'.paint.brightness  #=> 255.0\r\n'black'.paint.brightness  #=> 0.0\r\n\r\n# complement\r\n'red'.paint.complement #=> cyan\r\n```\r\n\r\n## Contributing\r\n\r\nPlease branch from **dev** for all pull requests.\r\n\r\n1. Fork it (https://github.com/jfairbank/chroma/fork)\r\n2. Checkout dev (`git checkout dev`)\r\n3. Create your feature branch (`git checkout -b my-new-feature`)\r\n4. Commit your changes (`git commit -am 'Add some feature'`)\r\n5. Push to the branch (`git push origin my-new-feature`)\r\n6. Create a new pull request against dev\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}